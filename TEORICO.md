Aplicação recomendada e ciclo de vida de fragments e activitys.

O ciclo de vida de uma activity começa com o método onCreate(), que é onde ocorre o vínculo entre o Layout e a classe, logo depois, temos o onStart, método responsável pela inicialização da tela, não necessariamente contendo informações. Depois, temos o onResume, que é o método responsável pelo recebimento de ações realizados pelo usuário, neste ponto, a Activity já está em execução e recebendo interações do usuário. O próximo método é chamado de onPause, e é executado quando o sistema está para retomar alguma atividade, logo depois, temos o onStop é chamado quando a Activity não está mais visível ao usuário, sejá por estar ter sido destruída ou porque o usuário está em uma outra Activity, o método que segue é chamado de onRestart, e é executado logo antes da de uma Activity ser reiniciada, e, por fim, temos o onDestroy, é o último método e acontece logo antes de uma Activity ser destruída.


O ciclo de vida de um Fragment se resume em uma série de métodos, alguns comuns aos de uma Activity, e são descritos da seguinte forma: onAttached(), método responsável por atrelar um Fragment a uma Activity, em seguida, temos o método onCreate(): Método de criação do Fragment, logo depois, temos o onCreateView(), que é o método responsável pelo contato com o layout, o próximo é o onActivityCreated(), que tem uma particularidade, ele só é chamado quando o método onCreate da Activity já foi finalizado, é responsável pelo acesso e modificação dos elementos de uma tela.
Os métodos do ciclo de vida (onStart, onResume, onPause e onStop) tem as mesmas funções da própria Activity, portanto, não serão comentados, uma vez que já foram previamente explicados no ciclo de vida da Activity, serão apenas citados em suas respectivas ordens de execução.
O próximo método, se chama onStart, logo depois, temos o onResume e, assim o Fragment está efetivamente ativo, depois, temos os métodos onPause e onStop respectivamente, e, após, o método onDestroyView que é chamado quando o Fragment ainda existe, porém não pode ser mais acessada, depois, temos o onDestroy, que é chamado quando a Fragmente não está sendo utilizada mais, porém ainda está atrelada a Activity e, por fim, temos o método onDetach, que é quando o Fragment não está sendo utilizada e não está atrelada mais à Activity.

Para sabermos em quais situações devemos usar uma Activity ou um fragment, devemos ter em mente o tamanho do projeto e qual será a portabilidade do mesmo, e, mais importante que isso, deve-se ter noção de que, dentro de uma Activity, pode-se existir vários fragments, e, tanto os Fragments como as Activities tem seus prós e seus contras, no quesito implementação e gerenciamento. Os fragments tem como características positivas para uso, o fato de eles serem muito modularizados, fáceis de se reutilizar e simples de se usar para construção de layouts dinâmicos, mas tem, como características "negativas" quando comparadas a uma Activity o fato de ter um gerenciamento de ciclo de vida um pouco mais complicado de se realizar.
Já uma activity, tem como características positivas, a simplicidade de construção e gerenciamento de ciclo de vida, bem como a facilidade na criação e navegação de outras activities, no entanto, temos como característica negativa, um dos aspectos que geralmente é o motivo para se usar fragments em nossos layouts, que é o fato das Activities serem muito rígidas, o que, em alguns casos, não garante um bom resultado quando precisamos viasualizar nossos conteúdos em outros aparelhos que não sejam os que usamos como base para desenvolver um app.

A principal diferenças entre as arquiteturas MVP e MVVM é que, no caso da primeira, existe um Presenter, que tem a função básica de filtrar os dados que a View envia para o próprio Presenter graças à comunicação que os dois tem, ou seja, a View tem ciência do que está acontecendo no Presenter e o mesmo também tem ciência do que está acontecendo na View, o Presenter, nesse caso, decide a ação resposta da interação que o usuário teve na View.
Na arquitetura MVVM, a View sabe o que acontece no ModelView, mas este não sabe o acontece nna View, geralmente é utilizado por conferir uma certa automação entre as camadas de um código.
Muito embora a arquitetura tenha prós quando comparado à outra arquitetura, devemos ter em mente que, assim como no caso das Activities e dos Fragments, existem momentos em que o uso de uma é mais indicado que o de outra. A arquitetura MVP tem como destaque positivo, a reutilização de códigos e uma melhor separação de responsabilidades graças à independência que existe entre o model e os activities e fragments. Já na arquitetura MVVM, temos uma maior gama de possibilidades no quesito testabilidade e manutenção graças à separação que existe dentro do código, claro, se feito da maneira correta.
Nesse projeto, decidi fazer o uso da arquitetura MVVM graças à essas qualidades, além de levar em consideração que, muito embora ainda esteja em pleno uso, a tendência é que essa arquitetura seja cada vez mais adotada pelas grandes empresas de software.



Fontes: https://sites.google.com/site/amignon/tepoo/ciclo-de-vida-da-activity#:~:text=A%20Activity%20%C3%A9%20um%20componente,estados%20do%20ciclo%20de%20vida.
        https://jafapps.com.br/ciclo-de-vida-activity/
        https://developer.android.com/guide/components/fragments
        https://www.devmedia.com.br/ciclo-de-vida-do-fragments-no-android/33099
        https://www.thiengo.com.br/ciclo-de-vida-e-otimizacao-de-fragments-no-android
        https://www.it-swarm.dev/pt/android/qual-e-diferenca-entre-fragment-e-fragmentactivity/1067294840/#:~:text=A%20Fragment%20%C3%A9%20uma%20se%C3%A7%C3%A3o,o%20Activity%20est%C3%A1%20sendo%20executado.
        https://pt.stackoverflow.com/questions/17483/qual-a-diferen%C3%A7a-entre-desenhar-na-activity-e-no-fragment
        https://pt.stackoverflow.com/questions/21539/o-que-%C3%A9-mvp-e-mvvm#:~:text=No%20caso%20do%20MVVM%2C%20o,como%20um%20observador%20de%20ambas.
